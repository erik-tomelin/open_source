<h1>Principais Pontos Palestra TOTVS</h1>
	
<h2>Metodologias</h2>
SCRUM
KANBAN
Alteraram para o método de divisão de trabalho no modelo spotify

<h2>Utilizam Scrum e Kanban mesclado em equipes</h2>

<h2>Scrum e Kanban</h2>
<h2>Kanban</h2>
Exige comprometimento opcional
Usa lead time como métrica default para planejamento
Deixa adicionar novos itens quando houver capacidade
Sem diagramas
É limitado diretamente pelo fluxo de trabalho
Board é contínuo
<h2>Scrum</h2>
WIP é imitado diretamente pelo fluxo de trabalho

<h2>Daily</h2>
Tanto no Kanban quanto no Scrum
No Scrum é dito o que foi feito no dia anterior com relação ao progresso da sprint
No Kanban é com relação ao quadro, quem está realizando a atividade é quem fala da atividade

<h2>Planning</h2>
Encontrar o objetivo da Sprint
Participam todos os membro da equipe

<h2>Reabastecimento:</h2>
<h2>Planning do Kanban</h2>
Menos de 3 itens no to-do é marcado o reabastecimento
Participam todos os membros da equipe
<h2>Review</h2>
Entrega com relação ao ciclo completo
Para o PO e líderes
Finalização das Sprints 2 semanas
<h2>Retrospectiva</h2>
Ver os pontos a serem melhorados
Ver bons pontos
Dinâmicas para ter novas ideias
<h1>Método de Trabalho - Upstream</h1>
<table>
<tr>
<th>Backlog</th>
<th>Refinamento</th>
<th>Negócio</th>
<th>Refinamento</th>
<th>Negócio</th>
<th>Contínuo</th>
<th>Refinamento</th>
<th>Técnico</th>
<th>Refinamento</th>
<th>Técnico</th>
<th>Concluído</th>
</tr>
<tr>
<td>Backlog</td>
<td>Refinamento</td>
<td>Negócio</td>
<td>Refinamento</td>
<td>Negócio</td>
<td>Contínuo</td>
<td>Refinamento</td>
<td>Técnico</td>
<td>Refinamento</td>
<td>Técnico</td>
<td>Concluído</td>
</tr>
</table>

<h1>Método de Trabalho - Downstream</h1>
<table>
<tr>
<th>To Do</th>
<th>Desenvolvimento</th>
<th>Pronto Para Testar</th>
<th>Em Teste</th>
<th>Teste Concluído</th>
<th>Documentação</th>
<th>Pronto para Expedir</th>
<th>Concluído</th>
</tr>
<tr>
<td>To Do</td>
<td>Desenvolvimento</td>
<td>Pronto Para Testar</td>
<td>Em Teste</td>
<td>Teste Concluído</td>
<td>Documentação</td>
<td>Pronto para Expedir</td>
<td>Concluído</td>
</tr>
</table>

<h2>Plataforma FLUIG</h2>
Dividido em Squads
Utiliza aplicação Fluig No-Code
Liderança
Liderança por Influência
Não mudam no projeto

<h2>Importância do Design de produto</h2>
Descoberta
Design de Experiência de usuário
Prototipagem
Teste de Usuário

<h2>Experiência de Usuário</h2>
Introdução do usuário
trazer destaques e one boardings para as novas atividades
deve ser tratado o engajamento para manter os usuários e n apenas números de downloads
<h3>Design</h3>
Design Thinking e Lean Inception → técnicas usadas se complementando
<h3>Estimativas</h3>
perguntas para todas as partes afetadas, para encontrar todas as melhoras possíveis
integração e sinergia cada vez maior
<h3>Cronograma</h3>
Descobrir e Definir:
Briefing
Benchmarking
Personas
Matrizes CSD
Entrevistas
Jornadas de Usuário

<h2>Ideat e Decidir:</h2>
Como Nós Podemos 
Matriz de Priorização

<h2>Prototipar e Validar</h2>
Prototipação
Testes de Usabilidade e Análise
Protótipo de Alta Fidelidade
Plataforma MIRO
Para criação de design separadas por etapas e colunas (semelhante ao Figma)

<h2>S.A.R.A.</h2>
Situação
Ação
Resultados
Aprendizado

<h2>Produto</h2>
dentro das comunidades do fluig é possível adicionar a comunidade os formulários existentes e anda criar novos formulários com No-Code, jogando os elementos em         tela para montar e editar as configurações existentes
na timeline aparecem todos os acontecimentos, é possível curtir, salvar etc
ao preencher o formulário é possível avaliar o mesmo
dentro do formulário é possível ver em registros do formulário os dados das respostas

<h2>Carreira Tech</h2>
Trilha em Y
Gerencial ou Especialista
todos tem a mesma base, depois de um ponto é direcionado
sobre gradualmente com direção ao objetivo desejado
cargos pensados para chegar onde deseja


<h1>O que é GIT:</h1>

Git é um sistema de controle de versionamento distribuído, ou seja, um sistema em que outras pessoas ou times, podem participar editando um mesmo documento ou código ao mesmo tempo, sendo gerido através de versões que são criadas no instante em que existe uma modificação. O Git serve tanto como um sistema de integração como um sistema de versionamento.

<h3>Para utilizar o GIT é importante que você baixe as dependências dele.</h3>

Para criar um novo repositório, você precisa, através do terminal, entrar em um diretório que deseja criar um repositório. 
Código: git init
Com esse código irá criar um repositório no mesmo diretório e também um subdiretório chamado .git.

<h1><i>Código: git status</i></h1>
Através desse código você irá saber qual a versão que está no momento e também as possíveis modificações que você tem para atualizar.

<h1><i>Código: git add "nome_do_ arquivo.tipo"</i></h1>
Através desse código, os arquivos irão ser adicionados para o repositório com um status de “staged ”, que significa que o código estará em aguardo até próximo estado.

Para poder fazer as alterações no repositório é necessário que ele esteja em estágio de “staged”, para assim poder fazer um “commit“ e seguir com a atualização das alterações.

<h1><i>Código: git commit -m “ a mensagem que você quer colocar “</i></h1>
Esse código irá confirmar as alterações oficialmente no diretório. O -m serve para confirmar as modificações com alguma descrição ou aviso.

<h1><i>Código: git add "*.tipo"</i></h1>
Caso você queira deixar os arquivos em “staged” de todas as modificações que você fez no dia, pode utilizar o comando em que ele irá atualizar todos os arquivos do mesmo tipo de uma vez só.

<h1><i>Código: git commit -a </i></h1>
É utilizado caso queira fazer commits de todas as modificações que você já fez, porém sem precisar passar por um staged. Arquivos que foram adicionados e não foram acompanhados pelo git  não irão contar nesse commit.

<h1><i>Código: git reset</i></h1>
Caso queira remover os arquivos que estão em “staged” e voltar para o passo anterior.

<h1><i>Código: git log </i></h1>
Para ver o histórico de modificações no repositório e em ordem cronológica. 

Para tornar o git remoto é necessário você fazer uma conexão entre o seu repositório local e um repositório remoto. 

<h1><i>Código: git remote add origin https://github.com/suaconta/project.git</i></h1>
Esse é um exemplo através do github. Com a criação de um repositório no github, é feita a conexão e que então irá criar uma branch principal com o nome de origin para esse repositório remoto.

Quando se é iniciado um repositório, você estará em uma “branch” ou ramificação principal, nomeada como master. Para controle de versionamento é utilizado o conceito de ramificações.

Para enviar os arquivos que estão em seu repositório local, é importante “empurrar” esses arquivos para o repositório remoto informando as ramificações que serão utilizadas no processo. 

<h1><i>Código: git push -u origin master</i></h1>
Foi enviado os arquivos do repositório local na ramificação principal para o repositório remoto na ramificação principal.

<h1><i>Código: git pull origin master</i></h1>
Para atualizar seu repositório local com modificações que tenham acontecido no repositório remoto.

<h1><i>Código: git diff HEAD</i></h1>
A parte do git diff serve como uma análise de dados referentes aos repositórios, onde o HEAD serve como referência para a ramificação atual, comparando com uma última atualização recente

<h1><i>Código: git checkout "arquivo_arrependido.tipo".</i></h1>
Serve para retornar uma atualização do arquivo para uma atualização anterior. É utilizado para corrigir algum tipo de erro que possa ter acontecido ou arrependimento de atualizar.

<h1><i>Código: git branch nova_branch</i></h1>
Serve para criar uma nova ramificação do repositório.

<h1><i>Código: git checkout nome_branch</i></h1>
É utilizado para entrar em outras ramificações.

<h1><i>Código: git merge nome_branch</i></h1>
Irá fazer mesclar as modificações que você fez na branch citada na branch atual em que você está. Obs.: Tomar cuidado com esse código por favor.

<h1><i>Código: git -d nome_branch</i></h1>
Serve para deletar a ramificação atual, porém somente se tiver tido um pull e um merge para uma branch remota. Caso queira forçar o deletamento é necessário um -D ao invés de -d.

Quando acontece um conflito de um merge o git automaticamente “junta” os dois arquivos em um só informando que houve um problema na hora de mergear as 2 branchs.

Existem 3 tipos de resolução de conflito quando o mesmo acontece.

Aceitar as alterações da branch A.
Aceitar as alterações da branch B.
Aceitar ambas as alterações.

Os conflitos são muito variados e podem ter várias resoluções diferentes dependendo de onde a mesma está sendo aplicada.

<h1><i>Código: git cherry-pick <código do commit></i></h1>

O cherry-pick é um comando para puxar um commit específico de uma branch. Esse comando foi criado como uma alternativa mais precisa para o git merge pois o mesmo puxaria todas as alterações de uma branch. Já o cherry-pick puxaria apenas a parte do código que funciona com certeza.
Algumas vezes, o código criado por um desenvolvedor pode não funcionar 100%, justamente por ainda não ter passado por uma revisão e nesse caso, teria de ser feito o cherry-pick para que as alterações fossem mais precisas para outro desenvolvedor.


Membros da Equipe: Erik Tomelin, Gustavo Malkovski, Vinicius Ferri.
